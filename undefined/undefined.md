# 이펙티브 자바

## 2장 객체 생성과 파괴

### 아이템1 생성자 대신 정적 팩터리 메서드를 고려하라

클래스의 인스턴스를 얻는 가장 기본적인 방식은 public 생성자이다.

public 생성자 대신에 정적 팩터리 메서드를 고려하라.

#### 정적 팩터리 메서드의 장점은 무엇일까?

1. **이름을 가질 수 있다.** `BigInteger(int, int, Random)` 보다는 `BigInteger.probablePrime` 이 생성하는 행위의 역할을 더 잘 나타낸다.
2. **호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.**\
   반복되는 요청에 같은 객체를 반환하는 식인 정적 팩터리 메서드의 클래스는 언제 어느 인스턴스를 살아 있게 할 것인지 철저히 통제할 수 있다.\
   인스턴스를 통제하면, 클래스를 싱글턴 또는 인스턴스화 불가로 만들 수 있다.\
   또한 불변값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장 할 수 있다
3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**\
   ****_Q) 동반 클래스란?, TODO) 해당 부분 다시 이해 필요_
4. **입력 매개변수에 다라 매번 다른 클래스의 객체를 반환할 수 있다**
5. **정적 팩터리 메서드를 작서하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**

### 아이템2 생성자에 매개변수가 많다면 빌더를 고려하라

생성자에 매개변수가 많으면 각 매개변수들의 의미파악도 힘들고 매개변수의 순서나 갯수까지 파악해야하는 수고를 들여야한다.  대안으로 자바빈즈 패턴을 사용할 수 있다. 자바빈즈패턴은 매개변수없이 인스턴스를 생성하고 setter 로 인스턴스를 완성시키는 것이다. 자바빈즈패턴의 문제점은 객체 하나를 만드려면 여러 setter 메서드를 호출해줘야하고 그와중에 일관성이 사라진다. 들어가는 값이 유효한지 확인하는 방법이 사라지고 여러 setter 매서드들을 호출하면서 물리적으로 코드가 떨어져있기 때문에 디버깅도 만만치 않다.

세번째 대안으로 빌더 패턴이있다. 빌더패턴을 사용하면 완성된 객체를 일관성있게 불변으로 객체를 생성할 수 있다.

### 아이템3 private 생성자나 열거 타입으로 싱글턴임을 보증하라



싱글턴: 인스턴스를 오직하나만 생성할 수 있는 클래스

static 은 처음에 어플리케이션이 실행되었을때 가장 먼저 메모리에 올라가기 때문에 아래 코드처럼의 싱글톤이 가능

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();

    private Elvis() {

    }


}
```

유일하게 인스턴스를 두개 만들 수 있는 방법은 리플렉션(아이템65)을 활용해서 호출하는것이다. 이런 공격을 방어하려면 두번째 생성자 호출시 예외날리면 됨

두번째 방법은 정적 팩터리 방식의 싱글턴

```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {

    }

    public static Elvis getInstance() {
        return INSTANCE;
    }
}
```

이 방법이 public 방식과 다른 점은

1. API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다. 예를 들어 호출하는 스레드별로 다른 인스턴스를 넘겨줄 수 있게 할 수 있다 (이게 무슨말?)
2. 제네릭 싱글턴 팩터리 UnaryOperator
3. `Supplier<Elvis>` 형식

마지막 방법은 원소가 하나인 enum 사용

```java
public enum Kyu {
    INSTANCE
}
```
